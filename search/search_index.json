{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fibr command line tool \u00b6 More info can be found later here...","title":"Home"},{"location":"#welcome-to-fibr-command-line-tool","text":"More info can be found later here...","title":"Welcome to Fibr command line tool"},{"location":"about/","text":"Getting Started \u00b6 All you need to get started will be shown here ish.","title":"Getting Started"},{"location":"about/#getting-started","text":"All you need to get started will be shown here ish.","title":"Getting Started"},{"location":"about/development/","text":"Development \u00b6 Basic requirements at the outset of making the CLI \u00b6 Images here were made in excalidraw, really fun app. Basic Architecture \u00b6","title":"Development"},{"location":"about/development/#development","text":"","title":"Development"},{"location":"about/development/#basic-requirements-at-the-outset-of-making-the-cli","text":"Images here were made in excalidraw, really fun app.","title":"Basic requirements at the outset of making the CLI"},{"location":"about/development/#basic-architecture","text":"","title":"Basic Architecture"},{"location":"about/lab/","text":"Test page about the lab \u00b6 more info will follow here. \u00b6 g g g g g g g g","title":"Lab"},{"location":"about/lab/#test-page-about-the-lab","text":"","title":"Test page about the lab"},{"location":"about/lab/#more-info-will-follow-here","text":"g g g g g g g g","title":"more info will follow here."},{"location":"code/","text":"Here will be references to all the code stuff \u00b6 Whenever you load the DTI images. Do this. This might be shocking But this is in fact clickbait Lorem ipsum dolor sit amet Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Cras arcu libero Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor.","title":"Here will be references to all the code stuff"},{"location":"code/#here-will-be-references-to-all-the-code-stuff","text":"Whenever you load the DTI images. Do this. This might be shocking But this is in fact clickbait Lorem ipsum dolor sit amet Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis. Cras arcu libero Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante. Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor.","title":"Here will be references to all the code stuff"},{"location":"code/metrics/","text":"Calculating the relevant metrics \u00b6 Supported file formats. Tract files: .tck Reference Volumes: .nii.gz / .nii src . metrics . streamline2volume ( tract , reference_vol ) \u00b6 Generates bundle volume from streamline file Parameters: Name Type Description Default tract .tck tck tract file for one side as found in init args required Returns: Name Type Description output_vol numpy array array with binarized tract volume Source code in src/metrics.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def streamline2volume ( tract , reference_vol ): \"\"\"Generates bundle volume from streamline file Args: tract (.tck): tck tract file for one side as found in init args Returns: output_vol(numpy array): array with binarized tract volume \"\"\" # load reference nii and get the correct reference dimensions out of it reference = reference_vol ref_affine = reference . affine ref_dim = reference . header [ \"dim\" ][ 1 : 4 ] # load individual streamlines from the tract file streamlines = tract . tractogram . streamlines # transform streamlines to volume with dipy module tract_vol = density_map ( streamlines , affine = ref_affine , vol_dims = ref_dim ) output_vol = np . where ( tract_vol > 0.5 , 1 , 0 ) # binarize the volume return output_vol Take note Notes for this function src . metrics . stream_length ( stream ) \u00b6 Calculates length of individual stream. calculates lenght of a stream as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This function is needed to succesfully run some of the following functions that depend on individual stream lenghts. Parameters: Name Type Description Default stream numpy array individual stream as is found in the .tck files if you iterate over tract.streamlines. required Returns: Name Type Description stream_sum float The length of the stream Source code in src/metrics.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def stream_length ( stream ): \"\"\"Calculates length of individual stream. calculates lenght of a stream as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This function is needed to succesfully run some of the following functions that depend on individual stream lenghts. Args: stream (numpy array): individual stream as is found in the .tck files if you iterate over tract.streamlines. Returns: stream_sum(float): The length of the stream \"\"\" stream_sum = 0 for tt in range ( stream . shape [ 0 ] - 1 ): stream_sum += norm ( stream [ tt ] - stream [ tt + 1 ]) return stream_sum Take note Notes for this function src . metrics . tract_length ( tract ) \u00b6 Calculates average length of the tract calculates lenght of a tract as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the average length of individual stream lenghts within a tract Parameters: Name Type Description Default tract .tck see above required Returns: Name Type Description tract_length float average length of the tract Source code in src/metrics.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def tract_length ( tract ): \"\"\"Calculates average length of the tract calculates lenght of a tract as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the average length of individual stream lenghts within a tract Args: tract (.tck): see above Returns: tract_length(float): average length of the tract \"\"\" tract_streams = tract . streamlines stream_sums = [] for stream in tract_streams : stream_sums . append ( stream_length ( stream )) output = np . mean ( stream_sums ) return output Take note Notes for this function src . metrics . tract_span ( tract ) \u00b6 Calculates the span of the tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the mean of the distances between the starting points and ending points of the individual streams. Parameters: Name Type Description Default tract .tck see above required Returns: Name Type Description tract_span flaot span of the tract Source code in src/metrics.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def tract_span ( tract ): \"\"\"Calculates the span of the tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the mean of the distances between the starting points and ending points of the individual streams. Args: tract (.tck): see above Returns: tract_span(flaot): span of the tract \"\"\" tract_streams = tract . streamlines span_sums = [] for stream in tract_streams : span_sums . append ( norm ( stream [ 0 ] - stream [ - 1 ])) tract_span = np . mean ( span_sums ) return tract_span Take note Notes for this function src . metrics . tract_diameter ( tract , tract_vol ) \u00b6 Calculates diameter of tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 Basically simplifies the tract as a cilinder and calculates a diameter based on the tract lenght and tract volume. Parameters: Name Type Description Default tract .tck see above required tract_vol numpy_array see above required Returns: Name Type Description tract_diameter float the diameter of the tract Source code in src/metrics.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def tract_diameter ( tract , tract_vol ): \"\"\"Calculates diameter of tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 Basically simplifies the tract as a cilinder and calculates a diameter based on the tract lenght and tract volume. Args: tract (.tck): see above tract_vol (numpy_array): see above Returns: tract_diameter(float): the diameter of the tract \"\"\" length_metric = tract_length ( tract ) N_voxels = np . sum ( tract_vol ) volume = N_voxels diameter = 2 * np . sqrt ( volume / ( np . pi * length_metric )) return diameter Take note Notes for this function src . metrics . tract_surface_area ( tract_vol ) \u00b6 Calculates surface area of the tract Where the reference publication (https://doi.org/10.1016/j.neuroimage.2020.117329) uses voxel spacing to calculate the suface volume of the tract we use a marching cubes algorithm to approximage a surface mesh of the bundle and then calculate the area of that surface mesh. Parameters: Name Type Description Default tract_vol numpy_array see above required Returns: Name Type Description surface_area float surface area of tract Source code in src/metrics.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def tract_surface_area ( tract_vol ): \"\"\"Calculates surface area of the tract Where the reference publication (https://doi.org/10.1016/j.neuroimage.2020.117329) uses voxel spacing to calculate the suface volume of the tract we use a marching cubes algorithm to approximage a surface mesh of the bundle and then calculate the area of that surface mesh. Args: tract_vol (numpy_array): see above Returns: surface_area(float): surface area of tract \"\"\" verts , faces , _ , _ = marching_cubes ( tract_vol ) surface_area = mesh_surface_area ( verts , faces ) return surface_area Take note Notes for this function src . metrics . calculate_metrics ( tract , tract_vol ) \u00b6 Calculates all the metrics for a bundle and stores them in a dictionary Parameters: Name Type Description Default tract .tck tract file of one side of the bundle of interest required tract_vol numpy array 3d array of binarized tract volume (see streamline2volume function) required Returns: Name Type Description metrics_dict dict Source code in src/metrics.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def calculate_metrics ( tract , tract_vol ): \"\"\"Calculates all the metrics for a bundle and stores them in a dictionary Args: tract (.tck): tract file of one side of the bundle of interest tract_vol (numpy array): 3d array of binarized tract volume (see streamline2volume function) Returns: metrics_dict(dict): \"\"\" # Calculate all the metrics and assign to variables length_metric = tract_length ( tract ) span_metric = tract_span ( tract ) curl_metric = length_metric / span_metric diameter_metric = tract_diameter ( tract , tract_vol ) elongation_metric = length_metric / diameter_metric volume_metric = np . sum ( tract_vol ) surface_area_metric = tract_surface_area ( tract_vol ) irregularity_metric = surface_area_metric / \\ ( np . pi * diameter_metric * length_metric ) # Construct final dictionary to output metrics_dict = { 'tract_length' : length_metric , 'tract_span' : span_metric , 'tract_curl' : curl_metric , 'tract_diameter' : diameter_metric , 'tract_elongation' : elongation_metric , 'tract_volume' : volume_metric , 'tract_surface_area' : surface_area_metric , 'tract_irregularity' : irregularity_metric , } return metrics_dict Take note Notes for this function src . metrics . dict_append_suffix ( d , suffix ) \u00b6 Adds a suffix to all dictionary keys This is a helper function to make sure the dictionary keys are named correctly before they are integrated into a dataframe. Parameters: Name Type Description Default d dict dictionary where you want to add suffix required suffix str suffix you want to add required Returns: Type Description dict dictionary with update suffixes Source code in src/metrics.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def dict_append_suffix ( d : dict , suffix : str ): \"\"\"Adds a suffix to all dictionary keys This is a helper function to make sure the dictionary keys are named correctly before they are integrated into a dataframe. Args: d (dict): dictionary where you want to add suffix suffix (str): suffix you want to add Returns: (dict): dictionary with update suffixes \"\"\" old_keys = list ( d . keys ()) for ii in range ( len ( old_keys )): old_key = old_keys [ ii ] new_key = old_key + suffix d [ new_key ] = d [ old_key ] d . pop ( old_key ) return d Take note Notes for this function","title":"Calculating Metrics"},{"location":"code/metrics/#calculating-the-relevant-metrics","text":"Supported file formats. Tract files: .tck Reference Volumes: .nii.gz / .nii","title":"Calculating the relevant metrics"},{"location":"code/metrics/#src.metrics.streamline2volume","text":"Generates bundle volume from streamline file Parameters: Name Type Description Default tract .tck tck tract file for one side as found in init args required Returns: Name Type Description output_vol numpy array array with binarized tract volume Source code in src/metrics.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def streamline2volume ( tract , reference_vol ): \"\"\"Generates bundle volume from streamline file Args: tract (.tck): tck tract file for one side as found in init args Returns: output_vol(numpy array): array with binarized tract volume \"\"\" # load reference nii and get the correct reference dimensions out of it reference = reference_vol ref_affine = reference . affine ref_dim = reference . header [ \"dim\" ][ 1 : 4 ] # load individual streamlines from the tract file streamlines = tract . tractogram . streamlines # transform streamlines to volume with dipy module tract_vol = density_map ( streamlines , affine = ref_affine , vol_dims = ref_dim ) output_vol = np . where ( tract_vol > 0.5 , 1 , 0 ) # binarize the volume return output_vol Take note Notes for this function","title":"streamline2volume()"},{"location":"code/metrics/#src.metrics.stream_length","text":"Calculates length of individual stream. calculates lenght of a stream as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This function is needed to succesfully run some of the following functions that depend on individual stream lenghts. Parameters: Name Type Description Default stream numpy array individual stream as is found in the .tck files if you iterate over tract.streamlines. required Returns: Name Type Description stream_sum float The length of the stream Source code in src/metrics.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def stream_length ( stream ): \"\"\"Calculates length of individual stream. calculates lenght of a stream as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This function is needed to succesfully run some of the following functions that depend on individual stream lenghts. Args: stream (numpy array): individual stream as is found in the .tck files if you iterate over tract.streamlines. Returns: stream_sum(float): The length of the stream \"\"\" stream_sum = 0 for tt in range ( stream . shape [ 0 ] - 1 ): stream_sum += norm ( stream [ tt ] - stream [ tt + 1 ]) return stream_sum Take note Notes for this function","title":"stream_length()"},{"location":"code/metrics/#src.metrics.tract_length","text":"Calculates average length of the tract calculates lenght of a tract as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the average length of individual stream lenghts within a tract Parameters: Name Type Description Default tract .tck see above required Returns: Name Type Description tract_length float average length of the tract Source code in src/metrics.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def tract_length ( tract ): \"\"\"Calculates average length of the tract calculates lenght of a tract as part of calculating tract length in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the average length of individual stream lenghts within a tract Args: tract (.tck): see above Returns: tract_length(float): average length of the tract \"\"\" tract_streams = tract . streamlines stream_sums = [] for stream in tract_streams : stream_sums . append ( stream_length ( stream )) output = np . mean ( stream_sums ) return output Take note Notes for this function","title":"tract_length()"},{"location":"code/metrics/#src.metrics.tract_span","text":"Calculates the span of the tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the mean of the distances between the starting points and ending points of the individual streams. Parameters: Name Type Description Default tract .tck see above required Returns: Name Type Description tract_span flaot span of the tract Source code in src/metrics.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def tract_span ( tract ): \"\"\"Calculates the span of the tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 This basically takes the mean of the distances between the starting points and ending points of the individual streams. Args: tract (.tck): see above Returns: tract_span(flaot): span of the tract \"\"\" tract_streams = tract . streamlines span_sums = [] for stream in tract_streams : span_sums . append ( norm ( stream [ 0 ] - stream [ - 1 ])) tract_span = np . mean ( span_sums ) return tract_span Take note Notes for this function","title":"tract_span()"},{"location":"code/metrics/#src.metrics.tract_diameter","text":"Calculates diameter of tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 Basically simplifies the tract as a cilinder and calculates a diameter based on the tract lenght and tract volume. Parameters: Name Type Description Default tract .tck see above required tract_vol numpy_array see above required Returns: Name Type Description tract_diameter float the diameter of the tract Source code in src/metrics.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def tract_diameter ( tract , tract_vol ): \"\"\"Calculates diameter of tract calculates span of a tract as part of calculating metric described in: https://doi.org/10.1016/j.neuroimage.2020.117329 - table 1 Basically simplifies the tract as a cilinder and calculates a diameter based on the tract lenght and tract volume. Args: tract (.tck): see above tract_vol (numpy_array): see above Returns: tract_diameter(float): the diameter of the tract \"\"\" length_metric = tract_length ( tract ) N_voxels = np . sum ( tract_vol ) volume = N_voxels diameter = 2 * np . sqrt ( volume / ( np . pi * length_metric )) return diameter Take note Notes for this function","title":"tract_diameter()"},{"location":"code/metrics/#src.metrics.tract_surface_area","text":"Calculates surface area of the tract Where the reference publication (https://doi.org/10.1016/j.neuroimage.2020.117329) uses voxel spacing to calculate the suface volume of the tract we use a marching cubes algorithm to approximage a surface mesh of the bundle and then calculate the area of that surface mesh. Parameters: Name Type Description Default tract_vol numpy_array see above required Returns: Name Type Description surface_area float surface area of tract Source code in src/metrics.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def tract_surface_area ( tract_vol ): \"\"\"Calculates surface area of the tract Where the reference publication (https://doi.org/10.1016/j.neuroimage.2020.117329) uses voxel spacing to calculate the suface volume of the tract we use a marching cubes algorithm to approximage a surface mesh of the bundle and then calculate the area of that surface mesh. Args: tract_vol (numpy_array): see above Returns: surface_area(float): surface area of tract \"\"\" verts , faces , _ , _ = marching_cubes ( tract_vol ) surface_area = mesh_surface_area ( verts , faces ) return surface_area Take note Notes for this function","title":"tract_surface_area()"},{"location":"code/metrics/#src.metrics.calculate_metrics","text":"Calculates all the metrics for a bundle and stores them in a dictionary Parameters: Name Type Description Default tract .tck tract file of one side of the bundle of interest required tract_vol numpy array 3d array of binarized tract volume (see streamline2volume function) required Returns: Name Type Description metrics_dict dict Source code in src/metrics.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def calculate_metrics ( tract , tract_vol ): \"\"\"Calculates all the metrics for a bundle and stores them in a dictionary Args: tract (.tck): tract file of one side of the bundle of interest tract_vol (numpy array): 3d array of binarized tract volume (see streamline2volume function) Returns: metrics_dict(dict): \"\"\" # Calculate all the metrics and assign to variables length_metric = tract_length ( tract ) span_metric = tract_span ( tract ) curl_metric = length_metric / span_metric diameter_metric = tract_diameter ( tract , tract_vol ) elongation_metric = length_metric / diameter_metric volume_metric = np . sum ( tract_vol ) surface_area_metric = tract_surface_area ( tract_vol ) irregularity_metric = surface_area_metric / \\ ( np . pi * diameter_metric * length_metric ) # Construct final dictionary to output metrics_dict = { 'tract_length' : length_metric , 'tract_span' : span_metric , 'tract_curl' : curl_metric , 'tract_diameter' : diameter_metric , 'tract_elongation' : elongation_metric , 'tract_volume' : volume_metric , 'tract_surface_area' : surface_area_metric , 'tract_irregularity' : irregularity_metric , } return metrics_dict Take note Notes for this function","title":"calculate_metrics()"},{"location":"code/metrics/#src.metrics.dict_append_suffix","text":"Adds a suffix to all dictionary keys This is a helper function to make sure the dictionary keys are named correctly before they are integrated into a dataframe. Parameters: Name Type Description Default d dict dictionary where you want to add suffix required suffix str suffix you want to add required Returns: Type Description dict dictionary with update suffixes Source code in src/metrics.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def dict_append_suffix ( d : dict , suffix : str ): \"\"\"Adds a suffix to all dictionary keys This is a helper function to make sure the dictionary keys are named correctly before they are integrated into a dataframe. Args: d (dict): dictionary where you want to add suffix suffix (str): suffix you want to add Returns: (dict): dictionary with update suffixes \"\"\" old_keys = list ( d . keys ()) for ii in range ( len ( old_keys )): old_key = old_keys [ ii ] new_key = old_key + suffix d [ new_key ] = d [ old_key ] d . pop ( old_key ) return d Take note Notes for this function","title":"dict_append_suffix()"}]}